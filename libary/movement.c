#pragma config(Sensor, dgtl1,  encoderLT,      sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encoderRT,      sensorQuadEncoder)
#pragma config(Motor,  port5,           lt,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rt,            tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void fwd(float inches);
void left();
void right();
void resetEncoders();

const float radius = 2; //inches
const float diameter = 4; //inches
const float pie = 3.1415926535897932384;
const float circumference = diameter*radius;
const float fullRotation = 360; //There are 360 pulses for every rotation in the encoder.

void fwd(float inches)
{
	resetEncoders();
	float rotations = inches/circumference;
	//turns on motors.
	motor[lt] = 100;
	motor[rt] = 100;
	while(SensorValue[encoderLT]/fullRotation < rotations)
	{
		//keeps repeating until rotations exceed calculated value.
		if(SensorValue[encoderLT] > 0.80*rotations)
		{
			//If there is only 20% of rotations left, slow down to account for momentum.
			motor[lt] = 30;
			motor[rt] = 30;
		}
	}
	//turns off motors.
	motor[lt] = 0;
	motor[rt] = 0;
}

void left()
{
	//Simply just turn on left motor to move a distance for 1/4 of a circle while leaving the right one off?
	resetEncoders();
	float rotations = (circumference/4)/circumference;
	motor[lt] = 100;
	while(SensorValue[encoderLT]/fullRotation < rotations)
	{
		;
	}
	motor[lt] = 0;

}

void right()
{
	//Simply just turn on left motor to move a distance for 1/4 of a circle while leaving the right one off?
	resetEncoders();
	float rotations = (circumference/4)/circumference;
	motor[rt] = 100;
	while(SensorValue[encoderRT]/fullRotation < rotations)
	{
		;
	}
	motor[rt] = 0;

}

void resetEncoders()
{
	//resets both encoders
	SensorValue[encoderLT]=0;
	SensorValue[encoderRT]=0;
}
